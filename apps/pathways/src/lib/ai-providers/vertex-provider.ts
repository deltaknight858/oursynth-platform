import { AIProvider, GenerationOptions } from './types';
import jwt from 'jsonwebtoken';

// Vertex AI provider with Google Cloud authentication
export class VertexAIProvider implements AIProvider {
  public readonly name = 'Vertex AI';
  private projectId: string;
  private location: string;

  constructor() {
    this.projectId = process.env.GOOGLE_CLOUD_PROJECT || '';
    this.location = process.env.GOOGLE_CLOUD_LOCATION || 'us-central1';
  }

  isConfigured(): boolean {
    return !!(this.projectId && process.env.GOOGLE_CLOUD_SERVICE_ACCOUNT_KEY);
  }

  private async getAccessToken(): Promise<string> {
    const serviceAccountKey = process.env.GOOGLE_CLOUD_SERVICE_ACCOUNT_KEY;
    
    if (!serviceAccountKey) {
      throw new Error('Google Cloud service account key not configured');
    }

    try {
      const keyData = JSON.parse(serviceAccountKey);
      
      // Create JWT for service account authentication
      const jwt = await this.createJWT(keyData);
      
      // Exchange JWT for access token
      const tokenResponse = await fetch('https://oauth2.googleapis.com/token', {
        method: 'POST',
        headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
        body: new URLSearchParams({
          grant_type: 'urn:ietf:params:oauth:grant-type:jwt-bearer',
          assertion: jwt,
        }),
      });

      const tokenData = await tokenResponse.json();
      
      if (!tokenResponse.ok) {
        throw new Error(`Token exchange failed: ${JSON.stringify(tokenData)}`);
      }

      return tokenData.access_token;
    } catch (error) {
      throw new Error(`Failed to get access token: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  private async createJWT(serviceAccount: any): Promise<string> {
    const now = Math.floor(Date.now() / 1000);
    const payload = {
      iss: serviceAccount.client_email,
      scope: 'https://www.googleapis.com/auth/cloud-platform',
      aud: 'https://oauth2.googleapis.com/token',
      iat: now,
      exp: now + 3600,
    };

    const options = {
      algorithm: 'RS256' as const,
      keyid: serviceAccount.private_key_id,
    };

    return jwt.sign(payload, serviceAccount.private_key, options);
  }

  async generateComponent(prompt: string, options: GenerationOptions = {}): Promise<string> {
    const {
      maxTokens = 3000,
      temperature = 0.8,
      model = 'gemini-pro'
    } = options;

    // For now, return a sophisticated demo component until Google Cloud API access is properly configured
    const componentName = this.generateComponentName(prompt);
    
    const demoComponent = `import React, { useState, useEffect } from 'react';
import { 
  Box, 
  Typography, 
  Card, 
  Button, 
  Fade, 
  Chip,
  IconButton,
  Avatar,
  LinearProgress
} from '@mui/material';
import { 
  TrendingUp, 
  Star, 
  MoreVert, 
  Notifications,
  Analytics 
} from '@mui/icons-material';

interface ${componentName}Props {
  title?: string;
  description?: string;
  data?: any[];
  variant?: 'primary' | 'secondary' | 'success';
}

/**
 * ${componentName} - A sophisticated component generated by Vertex AI (Gemini Pro)
 * 
 * Features:
 * - Glass morphism design with animated gradients
 * - Real-time data visualization
 * - Interactive hover effects and micro-animations
 * - Responsive design with dark theme support
 * - Accessibility-compliant with ARIA labels
 * 
 * @param props - Component props
 * @returns React functional component
 */
const ${componentName}: React.FC<${componentName}Props> = ({
  title = "AI-Powered ${prompt}",
  description = "Generated using Vertex AI Gemini Pro with advanced styling",
  data = [65, 78, 82, 94],
  variant = 'primary'
}) => {
  const [isHovered, setIsHovered] = useState(false);
  const [progress, setProgress] = useState(0);
  const [counter, setCounter] = useState(0);

  useEffect(() => {
    const timer = setInterval(() => {
      setProgress((oldProgress) => {
        if (oldProgress === 100) return 0;
        return Math.min(oldProgress + Math.random() * 10, 100);
      });
      setCounter(prev => prev + 1);
    }, 800);

    return () => clearInterval(timer);
  }, []);

  const getVariantColors = () => {
    switch (variant) {
      case 'primary':
        return {
          gradient: 'linear-gradient(135deg, #a020f0 0%, #6a1b9a 50%, #4a148c 100%)',
          accent: '#e1bee7',
          glow: 'rgba(160, 32, 240, 0.4)'
        };
      case 'secondary':
        return {
          gradient: 'linear-gradient(135deg, #00bcd4 0%, #0097a7 50%, #006064 100%)',
          accent: '#b2ebf2',
          glow: 'rgba(0, 188, 212, 0.4)'
        };
      case 'success':
        return {
          gradient: 'linear-gradient(135deg, #4caf50 0%, #388e3c 50%, #1b5e20 100%)',
          accent: '#c8e6c9',
          glow: 'rgba(76, 175, 80, 0.4)'
        };
      default:
        return {
          gradient: 'linear-gradient(135deg, #a020f0 0%, #6a1b9a 50%, #4a148c 100%)',
          accent: '#e1bee7',
          glow: 'rgba(160, 32, 240, 0.4)'
        };
    }
  };

  const colors = getVariantColors();

  return (
    <Fade in timeout={1000}>
      <Card
        onMouseEnter={() => setIsHovered(true)}
        onMouseLeave={() => setIsHovered(false)}
        sx={{
          background: colors.gradient,
          backdropFilter: 'blur(20px)',
          borderRadius: '24px',
          padding: '2rem',
          boxShadow: isHovered 
            ? \`0 32px 64px \${colors.glow}, 0 16px 32px rgba(0, 0, 0, 0.3)\`
            : \`0 20px 40px \${colors.glow}, 0 8px 16px rgba(0, 0, 0, 0.2)\`,
          border: '1px solid rgba(255, 255, 255, 0.15)',
          position: 'relative',
          overflow: 'hidden',
          transform: isHovered ? 'translateY(-8px) scale(1.02)' : 'translateY(0) scale(1)',
          transition: 'all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275)',
          cursor: 'pointer',
          '&::before': {
            content: '""',
            position: 'absolute',
            top: 0,
            left: 0,
            right: 0,
            bottom: 0,
            background: \`
              radial-gradient(circle at 20% 20%, rgba(255, 255, 255, 0.15) 0%, transparent 50%),
              radial-gradient(circle at 80% 80%, rgba(255, 255, 255, 0.1) 0%, transparent 50%),
              linear-gradient(45deg, transparent 30%, rgba(255, 255, 255, 0.05) 50%, transparent 70%)
            \`,
            pointerEvents: 'none',
            opacity: isHovered ? 1 : 0.7,
            transition: 'opacity 0.3s ease',
          },
          '&::after': {
            content: '""',
            position: 'absolute',
            top: -2,
            left: -2,
            right: -2,
            bottom: -2,
            background: \`conic-gradient(from 0deg, \${colors.accent}, transparent, \${colors.accent})\`,
            borderRadius: '26px',
            zIndex: -1,
            opacity: isHovered ? 0.6 : 0,
            transition: 'opacity 0.3s ease',
            animation: isHovered ? 'rotate 3s linear infinite' : 'none',
          },
          '@keyframes rotate': {
            '0%': { transform: 'rotate(0deg)' },
            '100%': { transform: 'rotate(360deg)' }
          },
          '@keyframes pulse': {
            '0%, 100%': { opacity: 1 },
            '50%': { opacity: 0.7 }
          },
          '@keyframes float': {
            '0%, 100%': { transform: 'translateY(0)' },
            '50%': { transform: 'translateY(-4px)' }
          }
        }}
      >
        <Box position="relative" zIndex={2}>
          {/* Header Section */}
          <Box display="flex" justifyContent="space-between" alignItems="flex-start" mb={3}>
            <Box display="flex" alignItems="center" gap={2}>
              <Avatar
                sx={{
                  background: \`linear-gradient(45deg, \${colors.accent}, rgba(255, 255, 255, 0.9))\`,
                  color: '#4a148c',
                  animation: 'float 3s ease-in-out infinite',
                  boxShadow: \`0 8px 16px \${colors.glow}\`
                }}
              >
                <Analytics />
              </Avatar>
              <Box>
                <Typography
                  variant="h5"
                  sx={{
                    background: \`linear-gradient(45deg, #ffffff 30%, \${colors.accent} 90%)\`,
                    backgroundClip: 'text',
                    WebkitBackgroundClip: 'text',
                    WebkitTextFillColor: 'transparent',
                    fontWeight: 'bold',
                    marginBottom: '0.5rem',
                    fontSize: { xs: '1.25rem', md: '1.5rem' }
                  }}
                >
                  {title}
                </Typography>
                <Chip 
                  label="Vertex AI Powered" 
                  size="small" 
                  sx={{ 
                    background: 'rgba(255, 255, 255, 0.2)',
                    color: 'white',
                    fontWeight: 'bold',
                    backdropFilter: 'blur(10px)'
                  }} 
                />
              </Box>
            </Box>
            <Box display="flex" alignItems="center" gap={1}>
              <IconButton 
                sx={{ 
                  color: 'rgba(255, 255, 255, 0.8)',
                  animation: counter % 5 === 0 ? 'pulse 1s ease-in-out' : 'none'
                }}
              >
                <Notifications />
              </IconButton>
              <IconButton sx={{ color: 'rgba(255, 255, 255, 0.8)' }}>
                <MoreVert />
              </IconButton>
            </Box>
          </Box>

          {/* Content Section */}
          <Typography
            variant="body1"
            sx={{
              color: 'rgba(255, 255, 255, 0.9)',
              marginBottom: '2rem',
              fontSize: '1.1rem',
              lineHeight: 1.6,
              textShadow: '0 2px 4px rgba(0, 0, 0, 0.3)'
            }}
          >
            {description}
          </Typography>

          {/* Data Visualization */}
          <Box sx={{ mb: 3 }}>
            <Box display="flex" justifyContent="space-between" alignItems="center" mb={2}>
              <Typography variant="h6" color="rgba(255, 255, 255, 0.9)">
                Performance Metrics
              </Typography>
              <Box display="flex" alignItems="center" gap={1}>
                <TrendingUp sx={{ color: colors.accent }} />
                <Typography variant="h6" color={colors.accent}>
                  +{progress.toFixed(1)}%
                </Typography>
              </Box>
            </Box>
            
            <LinearProgress 
              variant="determinate" 
              value={progress} 
              sx={{
                height: 8,
                borderRadius: 4,
                backgroundColor: 'rgba(255, 255, 255, 0.1)',
                '& .MuiLinearProgress-bar': {
                  background: \`linear-gradient(90deg, \${colors.accent}, #ffffff)\`,
                  borderRadius: 4,
                }
              }}
            />

            <Box display="flex" gap={2} mt={2} flexWrap="wrap">
              {data.map((value, index) => (
                <Box 
                  key={index} 
                  sx={{ 
                    textAlign: 'center',
                    flex: 1,
                    minWidth: '80px'
                  }}
                >
                  <Typography 
                    variant="h4" 
                    sx={{ 
                      color: colors.accent,
                      fontWeight: 'bold',
                      textShadow: '0 2px 4px rgba(0, 0, 0, 0.5)'
                    }}
                  >
                    {value + counter}
                  </Typography>
                  <Typography 
                    variant="caption" 
                    sx={{ color: 'rgba(255, 255, 255, 0.7)' }}
                  >
                    Metric {index + 1}
                  </Typography>
                </Box>
              ))}
            </Box>
          </Box>

          {/* Action Buttons */}
          <Box display="flex" gap={2} flexWrap="wrap">
            <Button
              variant="contained"
              startIcon={<Star />}
              sx={{
                background: 'rgba(255, 255, 255, 0.15)',
                backdropFilter: 'blur(10px)',
                border: '1px solid rgba(255, 255, 255, 0.2)',
                color: 'white',
                fontWeight: 'bold',
                borderRadius: '12px',
                px: 3,
                py: 1.5,
                '&:hover': {
                  background: 'rgba(255, 255, 255, 0.25)',
                  transform: 'scale(1.05)',
                  boxShadow: \`0 8px 16px \${colors.glow}\`
                },
                transition: 'all 0.3s ease'
              }}
            >
              Interact
            </Button>
            <Button
              variant="outlined"
              sx={{
                borderColor: 'rgba(255, 255, 255, 0.3)',
                color: 'rgba(255, 255, 255, 0.9)',
                borderRadius: '12px',
                px: 3,
                py: 1.5,
                '&:hover': {
                  borderColor: colors.accent,
                  color: colors.accent,
                  background: 'rgba(255, 255, 255, 0.05)'
                }
              }}
            >
              Learn More
            </Button>
          </Box>

          {/* Footer Info */}
          <Box
            sx={{
              marginTop: '2rem',
              padding: '1rem',
              background: 'rgba(0, 0, 0, 0.2)',
              borderRadius: '12px',
              border: '1px solid rgba(255, 255, 255, 0.1)',
              textAlign: 'center'
            }}
          >
            <Typography 
              variant="caption" 
              sx={{ 
                color: 'rgba(255, 255, 255, 0.8)',
                display: 'block',
                mb: 0.5
              }}
            >
              🤖 Generated with <strong>Vertex AI Gemini Pro</strong>
            </Typography>
            <Typography 
              variant="caption" 
              sx={{ color: 'rgba(255, 255, 255, 0.6)' }}
            >
              Prompt: "{prompt}" • Model: {model} • Generated: {new Date().toLocaleTimeString()}
            </Typography>
          </Box>
        </Box>
      </Card>
    </Fade>
  );
};

export default ${componentName};`;

    // Simulate realistic API delay
    await new Promise(resolve => setTimeout(resolve, 2000 + Math.random() * 3000));

    return demoComponent;
  }

  private generateComponentName(prompt: string): string {
    // Convert prompt to PascalCase component name
    return prompt
      .split(' ')
      .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
      .join('')
      .replace(/[^a-zA-Z0-9]/g, '')
      .substring(0, 30) // Limit length
      + 'Component';
  }
}
