// Project Context Provider
// Manages project state and provides save functionality for the studio editor

'use client';

import React, { createContext, useContext, useCallback, ReactNode, useState, useRef, useEffect } from 'react';
import { debounce } from 'lodash';
import { useProject } from '@/lib/projects';
import type { Project, Node } from '@/types/projects';

// ========================================
// CONTEXT TYPES
// ========================================

type SaveStatus = 'idle' | 'saving' | 'saved' | 'error';

interface SaveState {
  status: SaveStatus;
  lastSaved: Date | null;
  error: string | null;
  retryCount: number;
}

interface ProjectContextValue {
  // Data
  project: Project | null;
  nodes: Node[];
  loading: boolean;
  error: string | null;
  
  // Save state
  saveState: SaveState;
  hasUnsavedChanges: boolean;
  
  // Actions
  setNodes: (nodes: Node[]) => void;
  saveProject: () => Promise<boolean>;
  forceSave: () => Promise<boolean>;
  refetch: () => Promise<void>;
  
  // Node operations
  addNode: (node: Omit<Node, 'id' | 'created_at' | 'updated_at'>) => Promise<Node | null>;
  updateNode: (id: number, updates: Partial<Node>) => Promise<boolean>;
  deleteNode: (id: number) => Promise<boolean>;
  
  // Bulk operations
  updateMultipleNodes: (updates: Array<{ id: number; updates: Partial<Node> }>) => Promise<boolean>;
}

// ========================================
// CONTEXT CREATION
// ========================================

const ProjectContext = createContext<ProjectContextValue | null>(null);

// ========================================
// PROVIDER COMPONENT
// ========================================

interface ProjectProviderProps {
  projectId: number;
  children: ReactNode;
}

export function ProjectProvider({ projectId, children }: ProjectProviderProps) {
  const {
    project,
    nodes,
    loading,
    error,
    refetch,
    updateNodes
  } = useProject(projectId);

  // ========================================
  // SAVE STATE MANAGEMENT
  // ========================================

  const [saveState, setSaveState] = useState<SaveState>({
    status: 'idle',
    lastSaved: null,
    error: null,
    retryCount: 0
  });

  const [hasUnsavedChanges, setHasUnsavedChanges] = useState(false);
  const lastSavedNodesRef = useRef<Node[]>([]);
  const saveTimeoutRef = useRef<NodeJS.Timeout | null>(null);

  // Check for unsaved changes whenever nodes change
  useEffect(() => {
    if (nodes.length === 0 && lastSavedNodesRef.current.length === 0) {
      setHasUnsavedChanges(false);
      return;
    }

    const hasChanges = JSON.stringify(nodes) !== JSON.stringify(lastSavedNodesRef.current);
    setHasUnsavedChanges(hasChanges);
  }, [nodes]);

  // Auto-save on unmount
  useEffect(() => {
    return () => {
      if (saveTimeoutRef.current) {
        clearTimeout(saveTimeoutRef.current);
      }
      if (hasUnsavedChanges) {
        // Attempt synchronous save on unmount
        forceSaveSync();
      }
    };
  }, [hasUnsavedChanges]);

  // ========================================
  // SAVE FUNCTIONS
  // ========================================

  const forceSaveSync = () => {
    if (!projectId || !hasUnsavedChanges) return;
    
    try {
      // Synchronous save for emergency situations
      navigator.sendBeacon('/api/save-project', JSON.stringify({
        projectId,
        nodes
      }));
    } catch (error) {
      console.warn('Emergency save failed:', error);
    }
  };

  const performSave = useCallback(async (retryAttempt = 0): Promise<boolean> => {
    if (!projectId || !hasUnsavedChanges) return true;

    setSaveState(prev => ({
      ...prev,
      status: 'saving',
      error: null
    }));

    try {
      // For development mode, simulate successful save without hitting database 
      console.log('Development mode: Simulating save of', nodes.length, 'nodes');
      
      // Simulate a brief delay
      await new Promise(resolve => setTimeout(resolve, 200));
      
      lastSavedNodesRef.current = [...nodes];
      setHasUnsavedChanges(false);
      setSaveState(prev => ({
        ...prev,
        status: 'saved',
        lastSaved: new Date(),
        error: null,
        retryCount: 0
      }));

      // Clear saved status after 2 seconds
      setTimeout(() => {
        setSaveState(prev => prev.status === 'saved' ? { ...prev, status: 'idle' } : prev);
      }, 2000);

      return true;
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Unknown save error';
      console.error('Save failed:', error);

      setSaveState(prev => ({
        ...prev,
        status: 'error',
        error: errorMessage,
        retryCount: retryAttempt + 1
      }));

      return false;
    }
  }, [projectId, nodes, hasUnsavedChanges]);

  // Debounced save function
  const debouncedSave = useCallback(
    debounce(() => {
      performSave();
    }, 1000), // Save after 1 second of inactivity
    [performSave]
  );

  const saveProject = useCallback(async (): Promise<boolean> => {
    // Trigger debounced save
    debouncedSave();
    return true; // Return immediately, actual save happens async
  }, [debouncedSave]);

  const forceSave = useCallback(async (): Promise<boolean> => {
    // Cancel any pending debounced save
    debouncedSave.cancel();
    return performSave();
  }, [debouncedSave, performSave]);

  // Keyboard shortcuts
  useEffect(() => {
    const handleKeyDown = (event: KeyboardEvent) => {
      // Ctrl+S or Cmd+S to force save
      if ((event.ctrlKey || event.metaKey) && event.key === 's') {
        event.preventDefault();
        forceSave();
      }
    };

    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, [forceSave]);

  // ========================================
  // NODE OPERATIONS
  // ========================================

  const setNodes = useCallback((newNodes: Node[]) => {
    updateNodes(newNodes);
    // Trigger auto-save after nodes change
    debouncedSave();
  }, [updateNodes, debouncedSave]);

  const addNode = useCallback(async (nodeData: Omit<Node, 'id' | 'created_at' | 'updated_at'>): Promise<Node | null> => {
    if (!projectId) return null;

    try {
      // For development mode, create node entirely in memory
      const newNode: Node = {
        ...nodeData,
        id: Date.now() + Math.random(), // Generate unique ID
        project_id: projectId,
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString()
      };
      
      // Add to local state immediately
      const updatedNodes = [...nodes, newNode];
      setNodes(updatedNodes);
      
      console.log('Development mode: Node added to in-memory storage:', newNode.type);
      
      // Mark as having unsaved changes and trigger auto-save (but won't actually save to DB)
      setHasUnsavedChanges(true);
      debouncedSave();
      
      return newNode;
    } catch (error) {
      console.error('Error adding node:', error);
      setSaveState(prev => ({
        ...prev,
        status: 'error',
        error: 'Failed to add component'
      }));
      return null;
    }
  }, [projectId, nodes, setNodes, debouncedSave]);

  const updateNode = useCallback(async (id: number, updates: Partial<Node>): Promise<boolean> => {
    if (!projectId) return false;

    try {
      // Find the existing node
      const existingNode = nodes.find(n => n.id === id);
      if (!existingNode) return false;

      // Merge updates with existing node
      const updatedNode = { ...existingNode, ...updates };
      
      // For development mode, update in-memory without database
      const updatedNodes = nodes.map(n => n.id === id ? updatedNode : n);
      setNodes(updatedNodes);
      setHasUnsavedChanges(true);
      debouncedSave();
      
      console.log('Development mode: Updated node', id, 'in memory');
      return true;
    } catch (error) {
      console.error('Error updating node:', error);
      setSaveState(prev => ({
        ...prev,
        status: 'error',
        error: 'Failed to update component'
      }));
      return false;
    }
  }, [projectId, nodes, setNodes, debouncedSave]);

  const deleteNode = useCallback(async (id: number): Promise<boolean> => {
    if (!projectId) return false;

    try {
      // Remove node from current nodes array
      const remainingNodes = nodes.filter(n => n.id !== id);
      
      // For development mode, update in-memory without database
      setNodes(remainingNodes);
      setHasUnsavedChanges(true);
      debouncedSave();
      
      console.log('Development mode: Deleted node', id, 'from memory');
      return true;
    } catch (error) {
      console.error('Error deleting node:', error);
      setSaveState(prev => ({
        ...prev,
        status: 'error',
        error: 'Failed to delete component'
      }));
      return false;
    }
  }, [projectId, nodes, setNodes, debouncedSave]);

  const updateMultipleNodes = useCallback(async (
    updates: Array<{ id: number; updates: Partial<Node> }>
  ): Promise<boolean> => {
    if (!projectId) return false;

    try {
      // Apply all updates to the nodes array
      const updatedNodes = nodes.map(node => {
        const update = updates.find(u => u.id === node.id);
        return update ? { ...node, ...update.updates } : node;
      });

      // For development mode, update in-memory without database
      setNodes(updatedNodes);
      setHasUnsavedChanges(true);
      debouncedSave();
      
      console.log('Development mode: Updated', updates.length, 'nodes in memory');
      return true;
    } catch (error) {
      console.error('Error updating multiple nodes:', error);
      setSaveState(prev => ({
        ...prev,
        status: 'error',
        error: 'Failed to update components'
      }));
      return false;
    }
  }, [projectId, nodes, setNodes, debouncedSave]);

  // ========================================
  // CONTEXT VALUE
  // ========================================

  const contextValue: ProjectContextValue = {
    // Data
    project,
    nodes,
    loading,
    error,
    
    // Save state
    saveState,
    hasUnsavedChanges,
    
    // Actions
    setNodes,
    saveProject,
    forceSave,
    refetch,
    
    // Node operations
    addNode,
    updateNode,
    deleteNode,
    updateMultipleNodes
  };

  return (
    <ProjectContext.Provider value={contextValue}>
      {children}
    </ProjectContext.Provider>
  );
}

// ========================================
// HOOK TO USE CONTEXT
// ========================================

export function useProjectContext(): ProjectContextValue {
  const context = useContext(ProjectContext);
  
  if (!context) {
    throw new Error('useProjectContext must be used within a ProjectProvider');
  }
  
  return context;
}

// ========================================
// UTILITY HOOKS
// ========================================

/**
 * Hook to get current project info only (without nodes)
 */
export function useCurrentProject(): Pick<ProjectContextValue, 'project' | 'loading' | 'error'> {
  const { project, loading, error } = useProjectContext();
  return { project, loading, error };
}

/**
 * Hook to get project nodes with node operations
 */
export function useProjectNodes(): Pick<ProjectContextValue, 'nodes' | 'addNode' | 'updateNode' | 'deleteNode' | 'updateMultipleNodes'> {
  const { nodes, addNode, updateNode, deleteNode, updateMultipleNodes } = useProjectContext();
  return { nodes, addNode, updateNode, deleteNode, updateMultipleNodes };
}

/**
 * Hook for canvas operations (position, size updates)
 */
export function useCanvasOperations() {
  const { updateNode, updateMultipleNodes } = useProjectContext();

  const moveNode = useCallback(async (id: number, x: number, y: number): Promise<boolean> => {
    return updateNode(id, { x, y });
  }, [updateNode]);

  const resizeNode = useCallback(async (id: number, width: number, height: number): Promise<boolean> => {
    return updateNode(id, { width, height });
  }, [updateNode]);

  const moveNodes = useCallback(async (nodeUpdates: Array<{ id: number; x: number; y: number }>): Promise<boolean> => {
    const updates = nodeUpdates.map(({ id, x, y }) => ({
      id,
      updates: { x, y }
    }));
    return updateMultipleNodes(updates);
  }, [updateMultipleNodes]);

  const updateZIndex = useCallback(async (id: number, zIndex: number): Promise<boolean> => {
    return updateNode(id, { z_index: zIndex });
  }, [updateNode]);

  return {
    moveNode,
    resizeNode,
    moveNodes,
    updateZIndex
  };
}

/**
 * Hook to get save state and save controls
 */
export function useSaveState() {
  const { saveState, hasUnsavedChanges, saveProject, forceSave } = useProjectContext();
  
  return {
    saveState,
    hasUnsavedChanges,
    saveProject,
    forceSave,
    isLoading: saveState.status === 'saving',
    hasError: saveState.status === 'error',
    lastSaved: saveState.lastSaved
  };
}

export default ProjectProvider;
